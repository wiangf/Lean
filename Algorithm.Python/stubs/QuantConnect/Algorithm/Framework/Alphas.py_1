# encoding: utf-8
# module QuantConnect.Algorithm.Framework.Alphas calls itself Alphas
# from QuantConnect.Algorithm, Version=2.4.0.0, Culture=neutral, PublicKeyToken=null, QuantConnect.Algorithm.Framework, Version=2.4.0.0, Culture=neutral, PublicKeyToken=null
# by generator 1.145
# no doc

# imports
import datetime
import Python.Runtime
import QuantConnect
import QuantConnect.Algorithm
import QuantConnect.Algorithm.Framework.Alphas
import QuantConnect.Data
import QuantConnect.Data.UniverseSelection
import QuantConnect.Indicators
import QuantConnect.Securities
import System
import System.Collections.Generic
import typing

# no functions
# classes

class AlphaModel(System.object, QuantConnect.Algorithm.Framework.INotifiedSecurityChanges, QuantConnect.Algorithm.Framework.Alphas.IAlphaModel, QuantConnect.Algorithm.Framework.Alphas.INamedModel):
    """
    Provides a base class for alpha models.
    
    AlphaModel()
    """
    def OnSecuritiesChanged(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, changes: QuantConnect.Data.UniverseSelection.SecurityChanges) -> None:
        pass

    def Update(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, data: QuantConnect.Data.Slice) -> typing.List[QuantConnect.Algorithm.Framework.Alphas.Insight]:
        pass

    Name: str



class AlphaModelExtensions(System.object):
    """ Provides extension methods for alpha models """
    @staticmethod
    def GetModelName(model: QuantConnect.Algorithm.Framework.Alphas.IAlphaModel) -> str:
        pass

    __all__: list


class AlphaModelPythonWrapper(QuantConnect.Algorithm.Framework.Alphas.AlphaModel, QuantConnect.Algorithm.Framework.INotifiedSecurityChanges, QuantConnect.Algorithm.Framework.Alphas.IAlphaModel, QuantConnect.Algorithm.Framework.Alphas.INamedModel):
    """
    Provides an implementation of QuantConnect.Algorithm.Framework.Alphas.IAlphaModel that wraps a Python.Runtime.PyObject object
    
    AlphaModelPythonWrapper(model: PyObject)
    """
    def OnSecuritiesChanged(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, changes: QuantConnect.Data.UniverseSelection.SecurityChanges) -> None:
        pass

    def Update(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, data: QuantConnect.Data.Slice) -> typing.List[QuantConnect.Algorithm.Framework.Alphas.Insight]:
        pass

    @staticmethod # known case of __new__
    def __new__(self, model: Python.Runtime.PyObject) -> None:
        pass

    Name: str



class BasePairsTradingAlphaModel(QuantConnect.Algorithm.Framework.Alphas.AlphaModel, QuantConnect.Algorithm.Framework.INotifiedSecurityChanges, QuantConnect.Algorithm.Framework.Alphas.IAlphaModel, QuantConnect.Algorithm.Framework.Alphas.INamedModel):
    """
    This alpha model is designed to accept every possible pair combination
                from securities selected by the universe selection model
                This model generates alternating long ratio/short ratio insights emitted as a group
    
    BasePairsTradingAlphaModel(lookback: int, resolution: Resolution, threshold: Decimal)
    """
    def HasPassedTest(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, asset1: QuantConnect.Symbol, asset2: QuantConnect.Symbol) -> bool:
        pass

    def OnSecuritiesChanged(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, changes: QuantConnect.Data.UniverseSelection.SecurityChanges) -> None:
        pass

    def Update(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, data: QuantConnect.Data.Slice) -> typing.List[QuantConnect.Algorithm.Framework.Alphas.Insight]:
        pass

    @staticmethod # known case of __new__
    def __new__(self, lookback: int, resolution: QuantConnect.Resolution, threshold: float) -> None:
        pass

    Securities: System.Collections.Generic.HashSet[QuantConnect.Securities.Security]



class CompositeAlphaModel(QuantConnect.Algorithm.Framework.Alphas.AlphaModel, QuantConnect.Algorithm.Framework.INotifiedSecurityChanges, QuantConnect.Algorithm.Framework.Alphas.IAlphaModel, QuantConnect.Algorithm.Framework.Alphas.INamedModel):
    """
    Provides an implementation of QuantConnect.Algorithm.Framework.Alphas.IAlphaModel that combines multiple alpha
                models into a single alpha model and properly sets each insights 'SourceModel' property.
    
    CompositeAlphaModel(*alphaModels: Array[IAlphaModel])
    CompositeAlphaModel(*alphaModels: Array[PyObject])
    CompositeAlphaModel(alphaModel: PyObject)
    """
    @typing.overload
    def AddAlpha(self, alphaModel: QuantConnect.Algorithm.Framework.Alphas.IAlphaModel) -> None:
        pass

    @typing.overload
    def AddAlpha(self, pyAlphaModel: Python.Runtime.PyObject) -> None:
        pass

    def AddAlpha(self, *args) -> None:
        pass

    def OnSecuritiesChanged(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, changes: QuantConnect.Data.UniverseSelection.SecurityChanges) -> None:
        pass

    def Update(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, data: QuantConnect.Data.Slice) -> typing.List[QuantConnect.Algorithm.Framework.Alphas.Insight]:
        pass

    @staticmethod # known case of __new__
    @typing.overload
    def __new__(self, alphaModels: typing.List[QuantConnect.Algorithm.Framework.Alphas.IAlphaModel]) -> None:
        pass

    @typing.overload
    def __new__(self, alphaModels: typing.List[Python.Runtime.PyObject]) -> None:
        pass

    @typing.overload
    def __new__(self, alphaModel: Python.Runtime.PyObject) -> None:
        pass

    def __new__(self, *args) -> None:
        pass


class ConstantAlphaModel(QuantConnect.Algorithm.Framework.Alphas.AlphaModel, QuantConnect.Algorithm.Framework.INotifiedSecurityChanges, QuantConnect.Algorithm.Framework.Alphas.IAlphaModel, QuantConnect.Algorithm.Framework.Alphas.INamedModel):
    """
    Provides an implementation of QuantConnect.Algorithm.Framework.Alphas.IAlphaModel that always returns the same insight for each security
    
    ConstantAlphaModel(type: InsightType, direction: InsightDirection, period: TimeSpan)
    ConstantAlphaModel(type: InsightType, direction: InsightDirection, period: TimeSpan, magnitude: Nullable[float], confidence: Nullable[float], weight: Nullable[float])
    """
    def OnSecuritiesChanged(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, changes: QuantConnect.Data.UniverseSelection.SecurityChanges) -> None:
        pass

    def Update(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, data: QuantConnect.Data.Slice) -> typing.List[QuantConnect.Algorithm.Framework.Alphas.Insight]:
        pass

    @staticmethod # known case of __new__
    @typing.overload
    def __new__(self, type: QuantConnect.Algorithm.Framework.Alphas.InsightType, direction: QuantConnect.Algorithm.Framework.Alphas.InsightDirection, period: datetime.timedelta) -> None:
        pass

    @typing.overload
    def __new__(self, type: QuantConnect.Algorithm.Framework.Alphas.InsightType, direction: QuantConnect.Algorithm.Framework.Alphas.InsightDirection, period: datetime.timedelta, magnitude: typing.Optional[float], confidence: typing.Optional[float], weight: typing.Optional[float]) -> None:
        pass

    def __new__(self, *args) -> None:
        pass


class EmaCrossAlphaModel(QuantConnect.Algorithm.Framework.Alphas.AlphaModel, QuantConnect.Algorithm.Framework.INotifiedSecurityChanges, QuantConnect.Algorithm.Framework.Alphas.IAlphaModel, QuantConnect.Algorithm.Framework.Alphas.INamedModel):
    """
    Alpha model that uses an EMA cross to create insights
    
    EmaCrossAlphaModel(fastPeriod: int, slowPeriod: int, resolution: Resolution)
    """
    def OnSecuritiesChanged(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, changes: QuantConnect.Data.UniverseSelection.SecurityChanges) -> None:
        pass

    def Update(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, data: QuantConnect.Data.Slice) -> typing.List[QuantConnect.Algorithm.Framework.Alphas.Insight]:
        pass

    @staticmethod # known case of __new__
    def __new__(self, fastPeriod: int, slowPeriod: int, resolution: QuantConnect.Resolution) -> None:
        pass


class HistoricalReturnsAlphaModel(QuantConnect.Algorithm.Framework.Alphas.AlphaModel, QuantConnect.Algorithm.Framework.INotifiedSecurityChanges, QuantConnect.Algorithm.Framework.Alphas.IAlphaModel, QuantConnect.Algorithm.Framework.Alphas.INamedModel):
    """
    Alpha model that uses historical returns to create insights
    
    HistoricalReturnsAlphaModel(lookback: int, resolution: Resolution)
    """
    def OnSecuritiesChanged(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, changes: QuantConnect.Data.UniverseSelection.SecurityChanges) -> None:
        pass

    def Update(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, data: QuantConnect.Data.Slice) -> typing.List[QuantConnect.Algorithm.Framework.Alphas.Insight]:
        pass

    @staticmethod # known case of __new__
    def __new__(self, lookback: int, resolution: QuantConnect.Resolution) -> None:
        pass


class IAlphaModel(QuantConnect.Algorithm.Framework.INotifiedSecurityChanges):
    """ Algorithm framework model that produces insights """
    def Update(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, data: QuantConnect.Data.Slice) -> typing.List[QuantConnect.Algorithm.Framework.Alphas.Insight]:
        pass


class INamedModel:
    """
    Provides a marker interface allowing models to define their own names.
                If not specified, the framework will use the model's type name.
                Implementation of this is not required unless you plan on running multiple models
                of the same type w/ different parameters.
    """
    Name: str



class MacdAlphaModel(QuantConnect.Algorithm.Framework.Alphas.AlphaModel, QuantConnect.Algorithm.Framework.INotifiedSecurityChanges, QuantConnect.Algorithm.Framework.Alphas.IAlphaModel, QuantConnect.Algorithm.Framework.Alphas.INamedModel):
    """
    Defines a custom alpha model that uses MACD crossovers. The MACD signal line is
                used to generate up/down insights if it's stronger than the bounce threshold.
                If the MACD signal is within the bounce threshold then a flat price insight is returned.
    
    MacdAlphaModel(fastPeriod: int, slowPeriod: int, signalPeriod: int, movingAverageType: MovingAverageType, resolution: Resolution)
    """
    def OnSecuritiesChanged(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, changes: QuantConnect.Data.UniverseSelection.SecurityChanges) -> None:
        pass

    def Update(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, data: QuantConnect.Data.Slice) -> typing.List[QuantConnect.Algorithm.Framework.Alphas.Insight]:
        pass

    @staticmethod # known case of __new__
    def __new__(self, fastPeriod: int, slowPeriod: int, signalPeriod: int, movingAverageType: QuantConnect.Indicators.MovingAverageType, resolution: QuantConnect.Resolution) -> None:
        pass


class NullAlphaModel(QuantConnect.Algorithm.Framework.Alphas.AlphaModel, QuantConnect.Algorithm.Framework.INotifiedSecurityChanges, QuantConnect.Algorithm.Framework.Alphas.IAlphaModel, QuantConnect.Algorithm.Framework.Alphas.INamedModel):
    """
    Provides a null implementation of an alpha model
    
    NullAlphaModel()
    """
    def Update(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, data: QuantConnect.Data.Slice) -> typing.List[QuantConnect.Algorithm.Framework.Alphas.Insight]:
        pass


class PearsonCorrelationPairsTradingAlphaModel(QuantConnect.Algorithm.Framework.Alphas.BasePairsTradingAlphaModel, QuantConnect.Algorithm.Framework.INotifiedSecurityChanges, QuantConnect.Algorithm.Framework.Alphas.IAlphaModel, QuantConnect.Algorithm.Framework.Alphas.INamedModel):
    """
    This alpha model is designed to rank every pair combination by its pearson correlation
                and trade the pair with the hightest correlation
                This model generates alternating long ratio/short ratio insights emitted as a group
    
    PearsonCorrelationPairsTradingAlphaModel(lookback: int, resolution: Resolution, threshold: Decimal, minimumCorrelation: float)
    """
    def HasPassedTest(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, asset1: QuantConnect.Symbol, asset2: QuantConnect.Symbol) -> bool:
        pass

    def OnSecuritiesChanged(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, changes: QuantConnect.Data.UniverseSelection.SecurityChanges) -> None:
        pass

    @staticmethod # known case of __new__
    def __new__(self, lookback: int, resolution: QuantConnect.Resolution, threshold: float, minimumCorrelation: float) -> None:
        pass


class RsiAlphaModel(QuantConnect.Algorithm.Framework.Alphas.AlphaModel, QuantConnect.Algorithm.Framework.INotifiedSecurityChanges, QuantConnect.Algorithm.Framework.Alphas.IAlphaModel, QuantConnect.Algorithm.Framework.Alphas.INamedModel):
    """
    Uses Wilder's RSI to create insights. Using default settings, a cross over below 30 or above 70 will
                trigger a new insight.
    
    RsiAlphaModel(period: int, resolution: Resolution)
    """
    def OnSecuritiesChanged(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, changes: QuantConnect.Data.UniverseSelection.SecurityChanges) -> None:
        pass

    def Update(self, algorithm: QuantConnect.Algorithm.QCAlgorithm, data: QuantConnect.Data.Slice) -> typing.List[QuantConnect.Algorithm.Framework.Alphas.Insight]:
        pass

    @staticmethod # known case of __new__
    def __new__(self, period: int, resolution: QuantConnect.Resolution) -> None:
        pass


